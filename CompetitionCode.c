#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, dgtl10, jumper,         sensorDigitalIn)
#pragma config(Sensor, dgtl11, claw,           sensorDigitalOut)
#pragma config(Sensor, dgtl12, led,            sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           forklift1,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftDrive,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           forklift2,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port5,           forklift5,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           forklift3,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           forklift4,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightDrive,    tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma DebuggerWindows("debugStream")
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


//Supporting Files
#include <Recorder.c>
#include <Playback.c>
//#include <SkillsPlayback.c>
//#include <SkillsRecorder.c>


//Variables
int maxSpeed = 128; //the robot will start with its maximum speed
int enableClaw = 1; //the claw is ready to be used
int autoChoice = 0;


void pre_auton() {

	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(1, "None");

	while(true) {

		string primary;
		sprintf(primary, "Primary: %1.2fV", nImmediateBatteryLevel/1000.0);
		bLCDBacklight = true;

		if(nLCDButtons == 1) { //left
			autoChoice--;
			if(autoChoice < -1)
				autoChoice = 1;

		}
		if(nLCDButtons == 2) { //Choose
			displayLCDCenteredString(0, "Choice Selected:");
			switch(autoChoice) {
				case -1: displayLCDCenteredString(1, "Leftside Autonomous"); break;
				case 0: displayLCDCenteredString(1, "Nothing"); break;
				case 1: displayLCDCenteredString(1, "Rightside Autonomous"); break;
			}
		}
			break;
		if(nLCDButtons == 4) { //Right
			autoChoice++;
			if(autoChoice > 1)
				autoChoice = -1;
		}
		switch(autoChoice) {
			case -1: displayLCDCenteredString(1, "Start Left"); break;
			case 0: displayLCDCenteredString(1, "None"); break;
			case 1: displayLCDCenteredString(1, "Start Right"); break;
		}
		displayLCDCenteredString(0, primary);
		delay(250);

	}
}


task autonomous() {
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	displayLCDCenteredString(0, "Running:");
	playback(autoChoice); //play the pre-recorded autonomous back
}


/*
	Main Controller
	---------------
		Joysticks:
			1	[None]
			2	Right Drive Control
			3	Left Drive Control
			4	[None]
		Buttons:
			5U && 5D	Claw Control
				5U -> Change Claw State
				5D ->
			6U && 6D Forklift Control
				6U -> Raise Forklift
				6D -> Lower Forklift
			7U && 7L && 7R && 7D  [None]
				7U ->
				7L && 7R ->
				7D ->
			8U && 8L && 8R && 8D Variable Drive Speed Control
				8U -> 128 maxSpeed
				8L && 8R -> 64 maxSpeed
				8D -> 32 maxSpeed
*/
task usercontrol() {

	//startTask(record); //Begin recording an autonomous or programming skills run

	clearTimer(T1); //Clear the timer

	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	while(true) { //Run for the duration of the entire driver control period

		string primary, secondary;
		sprintf(primary, "Primary: %1.2fV", nImmediateBatteryLevel/1000.0);
		sprintf(secondary, "Secondary: %1.2fV", powerExpander/182.4);

		displayLCDCenteredString(0, primary);
		displayLCDCenteredString(1, secondary);

		SensorValue[led] = SensorValue[jumper]; //Display the state of the jumper to the LED

		if(vexRT[Btn8U]) { //If button 8U is pressed
			maxSpeed = 128; //Change the maximum speed to 128 (maximum value)
		} else if(vexRT[Btn8L] || vexRT[Btn8R]) { //If buttons 8L or 8R are pressed
			maxSpeed = 64; //Change the maximum speed to 64 (1/2 of the maximum value)
		} else if(vexRT[Btn8D]) {
			maxSpeed = 32; //Change the maximum speed to 32 (1/4 of the maximum value)
		}

		motor[leftDrive] = vexRT[Ch2] * (maxSpeed / 128.0); //Control the left side of the drive train
		motor[rightDrive] = vexRT[Ch3] * (maxSpeed / 128.0); //Control the right side of the drive train

		if(!vexRT[Btn6U] && !vexRT[Btn6D]) { //If neither button 6U nor button 6D are pressed
			//Shut off the forklift
			motor[forklift1] = 0;
			motor[forklift2] = 0;
			motor[forklift3] = 0;
			motor[forklift4] = 0;
			motor[forklift5] = 0;
		} if(vexRT[Btn6U]) { //If button 6U is pressed
			//Raise the forklift at maximum speed
			motor[forklift1] = 128;
			motor[forklift2] = 128;
			motor[forklift3] = 128;
			motor[forklift4] = 128;
			motor[forklift5] = 128;
		} else if(vexRT[Btn6D]) { //If button 6D is pressed
			//Lower the forklift at maximum speed
		 	motor[forklift1] = -128;
			motor[forklift2] = -128;
			motor[forklift3] = -128;
			motor[forklift4] = -128;
			motor[forklift5] = -128;
		}


		if(vexRT[Btn5U] && enableClaw) { //If button 5U is pressed and enable claw has a non-zero value
			SensorValue[claw] = !SensorValue[claw]; //
			enableClaw = 0; //Set the value of enable claw to zero
			clearTimer(T1); //Clear the timer
		}

		if(time1(T1) > 250) { //If T1 has a value greater than 250 (ms)
			enableClaw = 1; //Set the value of enable claw to one
		}

	}
}
