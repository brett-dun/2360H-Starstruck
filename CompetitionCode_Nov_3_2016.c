#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port4,           leftCatapult,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rightCatapult, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           lift,          tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


//Functions
void extendBoomInches(float inches, int speed);
//void extendBoom(bool direction, int liftTime);
void turnDegrees(float angle , int speed);
void driveInches(float distance, int speed);

//Variables
int maxSpeed = 128;


void pre_auton() {
  bStopTasksBetweenModes = true;
}

task bringBoomHome() {
	extendBoomInches(14.5,-127);
	wait1Msec(320);
	motor[lift] = 0;
}
task auto1() {
	extendBoomInches(7, 127);
}
task auto2() {
	//driveInches(4*sqrt(24*24*2), 127);
	driveInches(3*24, 127);
	delay(1000);
	driveInches(18, -127);
	startTask(bringBoomHome);
}
task auto3() {
	driveInches(3*24, 127);
	driveInches(2*24, -127);
	turnDegrees(90, 127);
	startTask(bringBoomHome);
	driveInches(2.5*24, 127);
}
task auto4() {
	driveInches(3*24, 127);
	driveInches(2*24, -127);
	turnDegrees(-80, 127);
	startTask(bringBoomHome);
	driveInches(2.5*24, 127);
}
task forwardBackward() {
	extendBoomInches(7, 127);
	startTask(auto1);
	startTask(auto2);
}
task forwardBackwardCubeLeftStart() {
	extendBoomInches(7, 127);
	startTask(auto1);
	startTask(auto3);
}
task forwardBackwardCubeRightStart() {
	extendBoomInches(7, 127);
	startTask(auto1);
	startTask(auto4);
}
task autonomous() {
	//startTask(forwardBackward); //Either
	startTask(forwardBackwardCubeLeftStart); //Blue
	//startTask(forwardBackwardCubeRightStart); //Red
}


task usercontrol() {

	//nMotorEncoder[lift] = 14 / (0.5 * PI) * 627.2;
	nMotorEncoder[lift] = 0;

	while(true) {

		if(vexRT[Btn5U] && vexRT[Btn5D]) {
			nMotorEncoder[lift] = 0;
		}

		motor[leftDrive] = abs(vexRT[Ch3]) >= 4 ? vexRT[Ch3] * (maxSpeed / 128.0) : 0; //left side speed is determined by the left joystick
		motor[rightDrive] = abs(vexRT[Ch2]) >= 4 ? vexRT[Ch2] * (maxSpeed / 128.0) : 0; //right side speed is determined by the right joystick

		if(vexRT[Btn7U]) { //If button 7U is pressed
			maxSpeed = 128; //Change the maximum speed to 128 (maximum value)
		} else if(vexRT[Btn7L] || vexRT[Btn7R]) { //If buttons 7L or 7R are pressed
			maxSpeed = 64; //Change the maximum speed to 64 (1/2 of the maximum value)
		} else if(vexRT[Btn7D]) { //If button 7D is pressed
			maxSpeed = 32; //Change the maximum speed to 32 (1/4 of the maximum value)
		}

		if(vexRT[Btn8U] && !(abs(nMotorEncoder[lift]) >= 17.5 / (0.5 * PI) * 627.2)) {
			motor[lift] = 128;
		} else if(vexRT[Btn8D]) {
			motor[lift] = -128;
		}

		if(vexRT[Btn8L] || vexRT[Btn8R] || abs(nMotorEncoder[lift]) >= 17.5 / (0.5 * PI) * 627.2) {
			motor[lift] = 0;
		}

		motor[leftCatapult] = vexRT[Btn6D] || vexRT[Btn6U] ? 55 : 0;
		motor[rightCatapult] = vexRT[Btn6D] || vexRT[Btn6U] ? 55 : 0;
	}
}

/*
	angle > 0 && speed > 0 >>> clockwise
	angle > 0 && speed < 0 >>> counterclockwise
	angle < 0 && speed > 0 >>> counterclockwise
	angle < 0 && speed < 0 >>> clockwise
*/
void turnDegrees(float angle , int speed){ // 11.5^2 + 14.75^2 = c^2
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;
	speed = angle < 0 ? -speed : speed;
	const float ticks = abs((angle / 360) * (sqrt(pow(11.5,2) + pow(14.75,2)) / 4) * 392);
	motor[leftDrive] = speed;
	motor[rightDrive] = -speed;
	do{
		if(abs(nMotorEncoder[leftDrive]) >= ticks) {
			motor[leftDrive] = 0;
		}
		if(abs(nMotorEncoder[rightDrive]) >= ticks) {
			motor[rightDrive] = 0;
		}
	}	while(abs(nMotorEncoder[leftDrive]) < ticks || abs(nMotorEncoder[rightDrive]) < ticks);
	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
}

/*
	distance > 0 && speed > 0 >>> forward
	distance > 0 && speed < 0 >>> backward
	distance < 0 && speed > 0 >>> backward
	distance < 0 && speed < 0 >>> forward
*/
void driveInches(float distance, int speed) {
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;
	speed = distance < 0 ? -speed :  speed;
	const float rotations = abs(distance / (4 * PI) * 392);//627.2;
	do {
		motor[leftDrive] = abs(nMotorEncoder[leftDrive]) >= abs(nMotorEncoder[rightDrive]+50) ? speed * 0.95 : speed;
		motor[rightDrive] = abs(nMotorEncoder[rightDrive]) >= abs(nMotorEncoder[leftDrive]+50) ? speed * 0.95 : speed;
		if(abs(nMotorEncoder[leftDrive]) >= rotations) {
			motor[leftDrive] = 0;
		}
		if(abs(nMotorEncoder[rightDrive]) >= rotations) {
			motor[rightDrive] = 0;
		}
	} while(abs(nMotorEncoder[leftDrive]) < rotations || abs(nMotorEncoder[rightDrive]) < rotations);
  motor[leftDrive] = 0;
  motor[rightDrive] = 0;
}

void extendBoomInches(float inches, int speed) {
	nMotorEncoder[lift] = 0;
	const float ticks = abs(inches / (0.5 * PI) * 627.2);
	do {
		motor[lift] = speed;
	} while(abs(nMotorEncoder[lift]) < ticks);
	motor[lift] = 0;
}
