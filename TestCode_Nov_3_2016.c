#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port4,           rightCatapult, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftCatapult,  tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port9,           lift,          tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Functions
void extendBoomInches(float inches, int speed);
//void extendBoom(bool direction, int aliftTime);
void turnDegrees(float angle , int speed);
void driveInches(float distance, int speed);


//Variables
//bool extended = false;
int maxSpeed = 128;


task main() {



	//driveInches(10,32);
	//turnDegrees(90, 64);
	/*
	driveInches(2,64);
	driveInches(4,128);
	driveInches(3,64);
	driveInches(3,32);
	*/
		while (true) {

		motor[leftDrive] = abs(vexRT[Ch3]) >= 4 ? vexRT[Ch3] * (maxSpeed / 128.0) : 0; //left side speed is determined by the left joystick
		motor[rightDrive] = abs(vexRT[Ch2]) >= 4 ? vexRT[Ch2] * (maxSpeed / 128.0) : 0; //right side speed is determined by the right joystick

		//motor[leftDrive] = vexRT[Ch3] * (maxSpeed / 128.0);
		//motor[rightDrive] = vexRT[Ch2] * (maxSpeed / 128.0);

		/*if(vexRT[Btn5U] && !extended) { //If button 5U is pressed and the lift is not yet extended
			nMotorEncoder[lift] = 0; //Reset the motor encoder's value to 0
			motor[lift] = 128; //Rotate at full speed
			extended = !extended; //The lift is now extended
		} else if(vexRT[Btn5D] && extended) { //If button 5D is pressed and the lift is extended
			nMotorEncoder[lift] = 0; //Reset the motor encoder's value to 0
			motor[lift] = -128; //Rotate at full speed
			extended = !extended; //The lift is no longer extended
		}*/

		if(vexRT[Btn7U]) { //If button 7U is pressed
			maxSpeed = 128; //Change the maximum speed to 128 (maximum value)
		} else if(vexRT[Btn7L] || vexRT[Btn7R]) { //If buttons 7L or 7R are pressed
			maxSpeed = 64; //Change the maximum speed to 64 (1/2 of the maximum value)
		} else if(vexRT[Btn7D]) { //If button 7D is pressed
			maxSpeed = 32; //Change the maximum speed to 32 (1/4 of the maximum value)
		}

		if(vexRT[Btn8U]) {
			motor[lift] = 128;
		} else if(vexRT[Btn8D]) {
			motor[lift] = -128;
		}

		if(vexRT[Btn8L] || vexRT[Btn8R]) {
			motor[lift] = 0;
		}

		/*if(vexRT[Btn6D] || vexRT[Btn6U]) {
			nMotorEncoder[catapult1] = 0;
			do {
				motor[catapult1] = 64;
				motor[catapult2] = 64;
			} while(nMotorEncoder[catapult1] < 5.0 / 3.0 * 627.2);
			//delay(1500);
			motor[catapult1] = 0;
			motor[catapult2] = 0;
		}*/
		//motor[rightCatapult] = vexRT[Btn6D] || vexRT[Btn6U] ? 55 : 0;
		//motor[leftCatapult] = vexRT[Btn6D] || vexRT[Btn6U] ? 55 : 0;

		//Diameter of Gear * PI * Length of Extension Thing * Ticks Per Rotation
		/*const float ticks = 17 / (0.5 * PI) * 627.2; //The number of ticks needed to fully extend or retract the lift
		if(abs(nMotorEncoder[lift]) >= ticks || vexRT[Btn8L] || vexRT[Btn8R]) { //If the lift has turned at least the desired number of ticks
			motor[lift] = 0; //Shut the lift off
		}*/

	}

}

/*
	angle > 0 && speed > 0 >>> clockwise
	angle > 0 && speed < 0 >>> counterclockwise
	angle < 0 && speed > 0 >>> counterclockwise
	angle < 0 && speed < 0 >>> clockwise
*/
void turnDegrees(float angle , int speed){ // 11.5^2 + 14.75^2 = c^2
	nMotorEncoder[leftDrive] = 0; //Reset the motor encoder for the left side drive system
	nMotorEncoder[rightDrive] = 0; //Reset the motor encoder for the right side drive system
	speed = angle < 0 ? -speed : speed; //if the speed
	const float ticks = abs((angle / 360) * (sqrt(pow(11.5,2) + pow(14.75,2)) / 4) * 392);
	motor[leftDrive] = speed;
	motor[rightDrive] = -speed;
	do {
		motor[leftDrive] = atan((abs(nMotorEncoder[leftDrive])-ticks)/10) / (PI/2) * speed;
		motor[rightDrive] = -atan((abs(nMotorEncoder[rightDrive])-ticks)/10) / (PI/2) * speed;
		/*fif(abs(nMotorEncoder[leftDrive]) >= ticks) {
			motor[leftDrive] = 0;
		}
		if(abs(nMotorEncoder[rightDrive]) >= ticks) {
			motor[rightDrive] = 0;
		}*/
	}	while(abs(motor[leftDrive]) > 2 || abs(motor[rightDrive]) > 2);
	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
}

/*
	distance > 0 && speed > 0 >>> forward
	distance > 0 && speed < 0 >>> backward

	distance < 0 && speed > 0 >>> backward
	distance < 0 && speed < 0 >>> forward
*/
void driveInches(float distance, int speed) {
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;
	speed = distance < 0 ? -speed :  speed;
	const float rotations = abs(distance / (4 * PI) * 392);//392;
	do {
		motor[leftDrive] = abs(nMotorEncoder[leftDrive]) >= abs(nMotorEncoder[rightDrive]+50) ? speed * 0.95 : speed;
		motor[rightDrive] = abs(nMotorEncoder[rightDrive]) >= abs(nMotorEncoder[leftDrive]+50) ? speed * 0.95 : speed;
		if(abs(nMotorEncoder[leftDrive]) >= rotations) {
			motor[leftDrive] = 0;
		}
		if(abs(nMotorEncoder[rightDrive]) >= rotations) {
			motor[rightDrive] = 0;
		}
	} while(abs(nMotorEncoder[leftDrive]) < rotations || abs(nMotorEncoder[rightDrive]) < rotations);
  motor[leftDrive] = 0; //Shut off the left side drive system
  motor[rightDrive] = 0; //Shut off the right side drive system
}

void extendBoomInches(float inches, int speed) {
	nMotorEncoder[lift] = 0; //Reset the lift's motor encoder
	speed = inches < 0 ? -speed : speed;
	const float ticks = abs(inches / (0.5 * PI) * 627.2); //The number of ticks needed to extend or retract the lift
	do {
		motor[lift] = speed; //set the lift to the user specified speed
	} while(abs(nMotorEncoder[lift]) < ticks); //Keep doing this as long as the lift motors have not turned the required number of ticks
	motor[lift] = 0; //Shut off the lift
}
