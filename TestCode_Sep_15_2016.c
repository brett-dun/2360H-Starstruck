#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftDrive,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port4,           catapult1,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           catapult2,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lift,          tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Functions
void extendBoomInches(float inches, int speed);
//void extendBoom(bool direction, int liftTime);
void turnDegrees(float angle , int speed);
void driveInches(float distance, int speed);

//Variables
bool extended = false;
int maxSpeed = 128;


task main() {
	//driveInches(20, 64);
	turnDegrees(-90, -36);
	while(true) {

		motor[leftDrive] = vexRT[Ch3] * (maxSpeed / 128.0);
		motor[rightDrive] = vexRT[Ch2] * (maxSpeed / 128.0);

		if(vexRT[Btn5U] && !extended) {
			nMotorEncoder[lift] = 0;
			motor[lift] = 128; //(128 * 16 / 17.5);
			//motor[liftBottom] = (128 * 16.0 / 18);
			//clearTimer(T1);
			extended = !extended;
		} else if(vexRT[Btn5D] && extended) {
			nMotorEncoder[lift] = 0;
			motor[lift] = -128;
			//motor[liftBottom] = -(128 * 17.5 / 18);
			//clearTimer(T1);
			extended = !extended;
		}

		if(vexRT[Btn7U]) {
			maxSpeed = 128;
		} else if(vexRT[Btn7L] || vexRT[Btn7R]) {
			maxSpeed = 64;
		} else if(vexRT[Btn7D]) {
			maxSpeed = 32;
		}

		/*if(time1[T1] >= 4667+1000+250+50+25) { //Extend or retract for 5992 seconds
			motor[lift] = 0;
			//motor[liftBottom] = 0;
		}*/

		//Diameter of Gear * PI * Length of Extension Thing * Ticks Per Rotation
		const float distance = 17 / (0.5 * PI) * 627.2;
		if(nMotorEncoder[lift] >= distance || nMotorEncoder[lift] <= -distance) {
			motor[lift] = 0;
		}

		/*if(vexRT[Btn8D]) {
			motor[catapult1] = 64;
			motor[catapult2] = 64;
			clearTimer(T2);
		}*/

		/*if(time1[T2] >= 100) {
			motor[catapult1] = 0;
			motor[catapult2] = 0;
		}*/

	}
}


/*
	angle > 0 && speed > 0 >>> clockwise
	angle > 0 && speed < 0 >>> counterclockwise
	angle < 0 && speed > 0 >>> counterclockwise
	angle < 0 && speed < 0 >>> clockwise
*/
// 11.5^2 + 14.75^2 = c^2
void turnDegrees(float angle , int speed){
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;

	//speed = abs(speed); //Fix this
	speed = angle < 0 ? -speed : speed;


	const float ticks = abs((angle / 360) * (sqrt(pow(11.5,2) + pow(14.75,2)) / 4) * 392);

	motor[leftDrive] = speed;
	motor[rightDrive] = -speed;

	do{
		if(abs(nMotorEncoder[leftDrive]) >= ticks) {
			motor[leftDrive] = 0;
		}
		if(abs(nMotorEncoder[rightDrive]) >= ticks) {
			motor[rightDrive] = 0;
		}
	}	while(abs(nMotorEncoder[leftDrive]) < ticks || abs(nMotorEncoder[rightDrive]) < ticks);

	motor[leftDrive] = 0;
	motor[rightDrive] = 0;

}

/*
	distance > 0 && speed > 0 >>> forward
	distance > 0 && speed < 0 >>> backward
	distance < 0 && speed > 0 >>> backward
	distance < 0 && speed < 0 >>> forward
*/
void driveInches(float distance, int speed) {
	nMotorEncoder[leftDrive] = 0;
	nMotorEncoder[rightDrive] = 0;

	speed = distance < 0 ? -speed :  speed;

	const float rotations = abs(distance / (4 * PI) * 392);//627.2;

	motor[leftDrive] = speed;
	motor[rightDrive] = speed;

	do {
		if(abs(nMotorEncoder[leftDrive]) >= abs(nMotorEncoder[rightDrive]+50)) {
			motor[leftDrive] = speed * 0.95;
		} else {
			motor[leftDrive] = speed;
		}

		if(abs(nMotorEncoder[rightDrive]) >= abs(nMotorEncoder[leftDrive]+50)) {
			motor[rightDrive] = speed * 0.95;
		} else {
			motor[rightDrive] = speed;
		}

		if(abs(nMotorEncoder[leftDrive]) >= rotations) {
			motor[leftDrive] = 0;
		}
		if(abs(nMotorEncoder[rightDrive]) >= rotations) {
			motor[rightDrive] = 0;
		}

	} while(abs(nMotorEncoder[leftDrive]) < rotations || abs(nMotorEncoder[rightDrive]) < rotations);

  motor[leftDrive] = 0;
  motor[rightDrive] = 0;

}


//Controls lift system
/*void extendBoom(bool direction, int liftTime) {
	if(direction) {
		motor[topLeft] = -(128 * 16 / 17.5);
		motor[topRight] = -128;
		motor[bottomLeft] = -(128 * 16.0 / 18);
		motor[bottomRight] = -(128 * 16.0 / 18);
		//motor[hangLeft] = -128;
		//motor[hangRight] = -128;

	} else {
		motor[topLeft] = (128 * 16 / 17.5);
		motor[topRight] = 128;
		motor[bottomLeft] = (128 * 16.0 / 18);
		motor[bottomRight] = (128 * 16.0 / 18);
		//motor[hangLeft] = 128;
		//motor[hangRight] = 128;
	}
	delay(liftTime);
	//motor[hangLeft] = 0;
	//motor[hangRight] = 0;
	motor[topLeft] = 0;
	motor[topRight] = 0;
	motor[bottomLeft] = 0;
	motor[bottomRight] = 0;
}
*/

void extendBoomInches(float inches, int speed) {
	nMotorEncoder[lift] = 0;

	const float ticks = abs(inches / (0.5 * PI) * 627.2);

	do {
		motor[lift] = speed;
	} while(abs(nMotorEncoder[lift]) < ticks);

	motor[lift] = 0;
}
